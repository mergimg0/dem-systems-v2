<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="DEM Systems - Bespoke software solutions that transform complexity into simplicity for creative agencies.">

  <title>DEM Systems - Complexity to simplicity</title>

  <!-- Preconnect to font CDN -->
  <link rel="preconnect" href="https://api.fontshare.com" crossorigin>

  <!-- Preconnect to Cal.com for faster modal loading -->
  <link rel="preconnect" href="https://app.cal.com" crossorigin>

  <!-- Satoshi Font from Fontshare -->
  <link href="https://api.fontshare.com/v2/css?f[]=satoshi@400,500,600,700,900&display=swap" rel="stylesheet">

  <!-- Open Graph -->
  <meta property="og:title" content="DEM Systems - Complexity to simplicity">
  <meta property="og:description" content="Bespoke software solutions that transform complexity into simplicity.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://demsystems.com">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="DEM Systems - Complexity to simplicity">
  <meta name="twitter:description" content="Bespoke software solutions that transform complexity into simplicity.">

  <!-- Favicon placeholder -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>D</text></svg>">

  <!-- Stylesheets -->
  <link rel="stylesheet" href="css/reset.css">
  <link rel="stylesheet" href="css/main.css">

  <!-- Semantic Animation Styles -->
  <style>
    /* Smooth scrolling */
    html {
      scroll-behavior: smooth;
    }

    /* Sequential reveal - initial hidden state */
    [data-reveal-order] {
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    [data-reveal-order].revealed {
      opacity: 1;
      transform: translateY(0);
    }

    /* Shared animation word styles */
    .point-animation, .bespoke-animation, .friction-animation,
    .jargon-animation, .focus-animation, .matters-animation {
      position: relative;
      display: inline-block;
    }
    .point-word, .bespoke-word, .friction-word,
    .jargon-word, .focus-word, .matters-word {
      display: inline-flex;
    }
    .point-word .char, .bespoke-word .char, .friction-word .char,
    .jargon-word .char, .focus-word .char, .matters-word .char {
      display: inline-block;
      will-change: transform, opacity;
    }

    /* Point - dot that appears */
    .point-dot {
      position: absolute;
      width: 6px;
      height: 6px;
      background: currentColor;
      border-radius: 50%;
      opacity: 0;
      will-change: transform, opacity;
      pointer-events: none;
    }

    /* Jargon - scrambling effect */
    .jargon-word .char.scrambling {
      opacity: 0.7;
    }
    .jargon-word .char.decoded {
      opacity: 1;
    }

    /* Focus - context words */
    .focus-animation {
      display: inline;
    }
    .focus-context {
      display: inline;
      will-change: filter, opacity;
    }
    .focus-word {
      will-change: transform;
    }

    /* Matters - emphasis */
    .matters-word {
      will-change: transform;
    }

    /* Eliminate - strikethrough trapdoor */
    .eliminate-animation {
      position: relative;
      display: inline-block;
    }
    .eliminate-word {
      display: inline-flex;
      will-change: transform, opacity;
    }
    .eliminate-svg {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: visible;
      pointer-events: none;
    }
    .strike-line {
      stroke: currentColor;
      stroke-width: 2;
      stroke-dasharray: 200;
      stroke-dashoffset: 200;
    }

    /* Clarity - blur to clear */
    .clarity-animation {
      position: relative;
      display: inline-block;
    }
    .clarity-word {
      display: inline-flex;
      will-change: filter, opacity;
    }

    /* Path - wave motion */
    .path-animation {
      position: relative;
      display: inline-block;
    }
    .path-word {
      display: inline-flex;
    }
    .path-word .char {
      display: inline-block;
      will-change: transform;
    }

    /* Resistance - compress release */
    .resistance-animation {
      position: relative;
      display: inline-block;
    }
    .resistance-word {
      display: inline-flex;
    }
    .resistance-word .char {
      display: inline-block;
      will-change: transform;
    }

    /* Simplicity - emergence */
    .simplicity-animation {
      position: relative;
      display: inline-block;
    }
    .simplicity-word {
      display: inline-flex;
      will-change: filter, opacity, transform;
    }
    .simplicity-word .char {
      display: inline-block;
      will-change: transform, opacity;
    }
  </style>

  <!-- Reduced motion check -->
  <script>
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      document.documentElement.classList.add('reduced-motion');
    }
  </script>
</head>
<body>
  <!-- SVG Filter Definitions for Semantic Animations -->
  <svg class="sr-only" aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden;">
    <defs>
      <!-- Friction filter: feTurbulence + feDisplacementMap = visual noise + distortion -->
      <filter id="friction-filter" x="-50%" y="-50%" width="200%" height="200%">
        <feTurbulence id="friction-turbulence" type="turbulence" baseFrequency="0.02" numOctaves="2" result="noise"/>
        <feDisplacementMap id="friction-displacement" in="SourceGraphic" in2="noise" scale="6" xChannelSelector="R" yChannelSelector="G"/>
      </filter>
      <!-- Clarity filter: Gaussian blur that clears to sharp -->
      <filter id="clarity-filter" x="-10%" y="-10%" width="120%" height="120%">
        <feGaussianBlur id="clarity-blur" in="SourceGraphic" stdDeviation="3"/>
      </filter>
    </defs>
  </svg>

  <!-- Loading Progress Bar -->
  <div class="loading-bar" aria-hidden="true"></div>

  <!-- Skip Link for Accessibility -->
  <a href="#main-content" class="skip-link">Skip to main content</a>

  <!-- Desktop Navigation -->
  <header class="nav">
    <nav class="nav__container" aria-label="Main navigation">
      <a href="#" class="nav__logo" aria-label="DEM Systems - Back to top">
        <img class="logo-sprite" src="assets/sprites/dem-logo/dem-01.png" alt="" aria-hidden="true" draggable="false">
        <span class="nav__logo-text">DEM Systems</span>
      </a>
      <ul class="nav__links">
        <li><a href="#about" class="nav__link" data-text="About">About</a></li>
        <li><a href="#contact" class="nav__link" data-text="Contact">Contact</a></li>
      </ul>
    </nav>
  </header>
  <!-- Blackout overlay - paints from top of viewport, inverts everything via blend mode -->
  <div class="blackout-overlay" aria-hidden="true"></div>

  <!-- Period Rectangle SVG Overlay - draws on magnetic cursor capture -->
  <svg class="period-rect-svg" id="period-rect-svg" aria-hidden="true">
    <rect class="period-rect-path" id="period-rect-path" rx="4"/>
  </svg>

  <!-- Metamorphosis Canvas - 8-phase animation triggered by period capture -->
  <canvas id="metamorphosis-canvas" aria-hidden="true"></canvas>

  <!-- WebGL Thread Canvas (disabled until rope finessed) -->
  <!-- <canvas id="thread-canvas" aria-hidden="true"></canvas> -->

  <!-- Main Content -->
  <main id="main-content">

    <!-- Hero Section -->
    <section class="section section--hero" aria-labelledby="hero-title"
             data-video-playlist="assets/videos/combined.mp4,assets/videos/seamless-loop_00012.mp4,assets/videos/combined4.mp4,assets/videos/seamless-loop_00024.mp4,assets/videos/seamless-loop_00042.mp4">
      <div class="container">
        <div class="hero-title-wrapper">
          <!-- Canvas for video-masked text effect -->
          <div id="hero-video-text"
               class="hero-video-text-container hero-reveal"
               data-text="DEM Systems"
               data-video-playlist="assets/videos/combined.mp4,assets/videos/seamless-loop_00012.mp4,assets/videos/combined4.mp4,assets/videos/seamless-loop_00024.mp4,assets/videos/seamless-loop_00042.mp4"
               style="height: clamp(60px, 10vw, 120px); width: 100%;"
               aria-label="DEM Systems">
          </div>
          <!-- Fallback for reduced motion / no-JS -->
          <h1 id="hero-title" class="hero-title hero-title--fallback hero-reveal">DEM Systems</h1>
        </div>
        <!-- Primary tagline with kinetic typography -->
        <p class="hero-tagline hero-tagline--kinetic hero-reveal hero-reveal--delayed">
          Bespoke Software for Creative Agencies
        </p>
        <!-- Secondary tagline with typewriter effect -->
        <p class="hero-tagline hero-tagline--secondary hero-reveal" style="--reveal-delay: 300ms;">
          <span class="typewriter">
            <span class="typewriter__text"></span><span class="period-trigger" id="period-trigger">.</span>
            <span class="typewriter__cursor typewriter__cursor--blink">|</span>
          </span>
        </p>
      </div>
      <div class="scroll-indicator" aria-hidden="true">
        <span class="scroll-indicator__text">Scroll</span>
      </div>
    </section>

    <!-- About Section - Scrollytelling -->
    <section id="about" class="section section--about" aria-labelledby="about-title">
      <!-- Frame sequence canvas (renders behind text) -->
      <canvas id="about-canvas" class="about-canvas" aria-hidden="true"></canvas>

      <div class="container about-content">
        <h2 id="about-title" class="sr-only">About</h2>
        <div class="body-text">
          <p class="about-wipe">We <span class="sprite-hover-trigger" data-sprite="bricks">build</span> <span class="bespoke-animation" id="bespoke-animation"><span class="bespoke-word">bespoke</span></span> software solutions that <span class="eliminate-animation" id="eliminate-animation"><span class="eliminate-word">eliminate</span><svg class="eliminate-svg" viewBox="0 0 100 20" preserveAspectRatio="none"><line class="strike-line" x1="0" y1="10" x2="100" y2="10"/></svg></span> the <span class="friction-animation" id="friction-animation"><span class="friction-word">friction</span></span> <span class="point-animation" id="point-animation"><span class="point-word">points</span><span class="point-dot" aria-hidden="true"></span></span> <span class="sprite-hover-trigger" data-sprite="gears">grinding</span> your business to a halt.</p>
          <p class="about-wipe">No complicated <span class="jargon-animation" id="jargon-animation"><span class="sprite-hover-trigger" data-sprite="skulls"><span class="jargon-word">jargon</span></span></span>. No endless calls. Just the <span class="path-animation" id="path-animation"><span class="path-word">path</span></span> of least <span class="resistance-animation" id="resistance-animation"><span class="resistance-word">resistance</span></span> between where you are and where <span class="sprite-hover-trigger" data-sprite="desks" data-position="below">operational</span> <span class="sprite-hover-trigger" data-sprite="clarity" data-position="below"><span class="clarity-animation" id="clarity-animation"><span class="clarity-word">clarity</span></span></span> lives.</p>
          <p class="about-wipe">We handle the <span class="sprite-hover-trigger" data-sprite="wires" data-position="below">complex code</span> so <span class="focus-animation" id="focus-animation"><span class="focus-context">you can</span> <span class="focus-word">focus</span> <span class="focus-context">on the</span></span> work that <span class="matters-animation" id="matters-animation"><span class="matters-word">matters</span></span>.</p>
        </div>
      </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="section section--contact" aria-labelledby="contact-title">
      <div class="container">
        <div class="contact-content">
          <h2 id="contact-title" class="section-title contact-wipe">Book a conversation</h2>
          <p class="contact-subtext contact-wipe">No commitment. Just a conversation about what's possible.</p>

          <button class="cta contact-wipe"
                  data-cal-namespace="booking"
                  data-cal-link="ollie-roberts-ufdwdy/30min"
                  data-cal-config='{"layout":"month_view"}'
                  aria-label="Schedule a call via Cal.com">
            Schedule a call
          </button>

          <!-- Email fallback -->
          <p class="contact-email contact-wipe">
            Or email <a href="mailto:hello@demsystems.com">hello@demsystems.com</a>
          </p>
        </div>

        <!-- Contact Form (alternative to Calendly - uncomment to enable)
        <div class="form-container" data-reveal>
          <form id="contact-form" novalidate>
            <div class="form-fields">
              <div class="field-wrapper">
                <input
                  type="text"
                  name="name"
                  class="form-field"
                  placeholder="Your name"
                  required
                  aria-label="Your name"
                >
                <p class="field-error-message" aria-live="polite"></p>
              </div>

              <div class="field-wrapper">
                <input
                  type="email"
                  name="email"
                  class="form-field"
                  placeholder="your@email.com"
                  required
                  aria-label="Email address"
                >
                <p class="field-error-message" aria-live="polite"></p>
              </div>

              <div class="field-wrapper">
                <textarea
                  name="message"
                  class="form-field"
                  placeholder="Tell us about your project"
                  rows="4"
                  required
                  aria-label="Message"
                ></textarea>
                <p class="field-error-message" aria-live="polite"></p>
              </div>

              <button type="submit" class="submit-button">
                <span class="button-text">Send message</span>
                <span class="button-loader" aria-hidden="true"></span>
              </button>
            </div>

            <div class="success-message" aria-live="polite">
              <h3>Thank you</h3>
              <p>We'll be in touch within 24 hours.</p>
            </div>
          </form>
        </div>
        -->
      </div>
    </section>

  </main>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer__bottom">
        <p class="footer__copyright">&copy; 2026 DEM Systems</p>
        <a href="/privacy" class="footer__link footer__legal">Privacy</a>
      </div>
    </div>
  </footer>

  <!-- Mobile Bottom Navigation -->
  <nav class="mobile-nav" aria-label="Mobile navigation">
    <a href="#" class="mobile-nav__logo" aria-label="Back to top">DEM</a>
    <ul class="mobile-nav__links">
      <li><a href="#about" class="mobile-nav__link" data-text="About">About</a></li>
      <li><a href="#contact" class="mobile-nav__link" data-text="Contact">Contact</a></li>
    </ul>
  </nav>

  <!-- Three.js and Anime.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "animejs": "https://cdn.jsdelivr.net/npm/animejs/+esm"
      }
    }
  </script>

  <!-- Application Scripts -->
  <!-- <script type="module" src="js/thread.js"></script> --> <!-- Rope disabled temporarily -->
  <script type="module" src="js/main.js"></script>
  <script type="module" src="js/hero-video-reveal.js"></script>
  <script type="module" src="js/blackout.js"></script>
  <script type="module" src="js/nav.js"></script>
  <script type="module" src="js/form.js"></script>
  <script type="module" src="js/typewriter.js"></script>
  <!-- Sprite hover animation -->
  <script type="module" src="js/sprite-hover.js"></script>

  <!-- Kinetic Typography (Holke79-inspired baseline animation) -->
  <script type="module">
    import { initKineticTypography } from './js/kinetic-typography.js';
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => initKineticTypography());
    } else {
      initKineticTypography();
    }
  </script>

  <!-- About section scroll-wipe reveal (top-to-bottom) -->
  <script type="module">
    import { initAboutWipe } from './js/about-wipe.js';
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAboutWipe);
    } else {
      initAboutWipe();
    }
  </script>

  <!-- ============================================================
       SCROLL-TIED ANIMATION CONTROLLER
       Central controller for bidirectional scroll-scrubbed animations
       MUST be loaded BEFORE all animation modules that use it
       ============================================================ -->
  <script>
    // Collect all scroll-scrubbed animations (NOT a module - loads synchronously)
    window.scrollAnimations = [];

    // Register a scroll animation
    window.registerScrollAnimation = function(config) {
      window.scrollAnimations.push(config);
      // If we're already set up, do an immediate update
      if (window.scrollAnimationsReady) {
        window.updateScrollAnimations();
      }
    };

    // Update function
    window.updateScrollAnimations = function() {
      window.scrollAnimations.forEach(function(item) {
        var element = item.element;
        var update = item.update;
        if (!element) return;

        var rect = element.getBoundingClientRect();
        var vh = window.innerHeight;

        // Progress calculation:
        // Animation completes when element reaches viewport center (not when exiting)
        // rawProgress: 0 = entering, 0.5 = centered, 1 = exiting
        // progress: 0 = entering, 1 = centered (2x speed, clamped)
        var rawProgress = (vh - rect.top) / (vh + rect.height);
        var progress = Math.max(0, Math.min(1, rawProgress * 2));

        update(progress);
      });
    };

    // RAF-throttled scroll handler
    var ticking = false;

    window.addEventListener('scroll', function() {
      if (!ticking) {
        requestAnimationFrame(function() {
          window.updateScrollAnimations();
          ticking = false;
        });
        ticking = true;
      }
    }, { passive: true });

    // Also update on resize
    window.addEventListener('resize', function() {
      requestAnimationFrame(window.updateScrollAnimations);
    }, { passive: true });

    // Mark ready and do initial update after DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        window.scrollAnimationsReady = true;
        requestAnimationFrame(window.updateScrollAnimations);
      });
    } else {
      window.scrollAnimationsReady = true;
      requestAnimationFrame(window.updateScrollAnimations);
    }
  </script>

  <!-- Metamorphosis scroll fade: smooth opacity transition as user scrolls down -->
  <script>
    (function() {
      let metaCanvas = null;
      let hero = null;
      let ticking = false;

      function updateOpacity() {
        if (!hero || !metaCanvas) return;

        const rect = hero.getBoundingClientRect();
        const heroHeight = rect.height;
        const scrolled = -rect.top;

        // Fade starts at 5% scroll, fully faded at 30% (quick fade)
        const fadeStart = heroHeight * 0.05;
        const fadeEnd = heroHeight * 0.30;

        let opacity;
        if (scrolled <= fadeStart) {
          opacity = 1;
        } else if (scrolled >= fadeEnd) {
          opacity = 0;
        } else {
          opacity = 1 - (scrolled - fadeStart) / (fadeEnd - fadeStart);
        }

        metaCanvas.style.opacity = String(Math.max(0, Math.min(1, opacity)));
      }

      function onScroll() {
        if (!ticking) {
          requestAnimationFrame(() => {
            updateOpacity();
            ticking = false;
          });
          ticking = true;
        }
      }

      function init() {
        metaCanvas = document.getElementById('metamorphosis-canvas');
        hero = document.querySelector('.section--hero');
        if (metaCanvas && hero) {
          window.addEventListener('scroll', onScroll, { passive: true });
          updateOpacity();
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>

  <!-- HERO SCROLL TRIGGER: Auto-fire magnetic cursor at 30% + scroll-tied opacity fade -->
  <script type="module">
    import { triggerCapture, isTriggered, resetCapture } from './js/magnetic-cursor.js';
    import { initHeroVideoReveal } from './js/hero-video-reveal.js';

    const TRIGGER_THRESHOLD = 0.30; // 30% scroll through hero
    let isTriggeredState = false;

    // Cache DOM references
    let hero = null;
    let metaCanvas = null;
    let aboutContent = null;
    let periodRectSvg = null;

    function initRefs() {
      hero = document.querySelector('.section--hero');
      metaCanvas = document.getElementById('metamorphosis-canvas');
      aboutContent = document.querySelector('.about-content');
      periodRectSvg = document.getElementById('period-rect-svg');
    }

    function checkHeroScroll() {
      if (!hero) return;

      const rect = hero.getBoundingClientRect();
      const heroHeight = rect.height;
      const scrolledIntoHero = -rect.top;
      const progress = scrolledIntoHero / heroHeight;

      // --- TRIGGER at 30% (scrolling down) ---
      if (!isTriggeredState && progress >= TRIGGER_THRESHOLD && progress < 1) {
        isTriggeredState = true;

        // 1. Trigger magnetic cursor capture
        triggerCapture();

        // 2. Fade out video reveal
        if (window.fadeOutVideoReveal) {
          window.fadeOutVideoReveal();
        }

        console.log('[HeroScrollTrigger] Activated at', Math.round(progress * 100) + '%');
      }

      // --- RESET when scrolling back up past 30% ---
      if (isTriggeredState && progress < TRIGGER_THRESHOLD) {
        isTriggeredState = false;

        // Stop metamorphosis and close rectangle via scroll-owned reset
        resetCapture();
        if (window.stopMetamorphosis) {
          window.stopMetamorphosis();
        }

        // Hide metamorphosis canvas + rectangle immediately
        if (metaCanvas) {
          metaCanvas.style.opacity = '0';
        }
        if (periodRectSvg) {
          periodRectSvg.style.opacity = '';  // restore CSS control
        }

        // Re-initialize video reveal if not already running
        if (!window.__heroVideoReveal) {
          const playlistAttr = hero.dataset.videoPlaylist || '';
          const videoPlaylist = playlistAttr ? playlistAttr.split(',').map(s => s.trim()).filter(Boolean) : [];

          const instance = initHeroVideoReveal({
            heroSelector: '.section--hero',
            videoSrc: hero.dataset.videoSrc || 'assets/videos/dem-loop-08.webm',
            fallbackSrc: hero.dataset.fallbackSrc || 'assets/videos/dem-loop-08.mp4',
            videoPlaylist,
            revealRadius: parseInt(hero.dataset.revealRadius, 10) || 180,
            edgeSoftness: parseInt(hero.dataset.edgeSoftness, 10) || 50,
            opacity: parseFloat(hero.dataset.videoOpacity) || 0.95
          });

          if (instance) {
            window.__heroVideoReveal = instance;
            const canvas = hero.querySelector('canvas');
            if (canvas) {
              canvas.style.transition = 'opacity 0.3s ease-in';
              canvas.style.opacity = '1';
            }
          }
        }

        console.log('[HeroScrollTrigger] Reset - video reveal restored');
      }

      // --- RELEASE CURSOR when hero scrolls fully off-screen ---
      if (isTriggeredState && progress >= 1.0) {
        resetCapture(); // Frees cursor from period lock (early-returns if already released)
      }

      // --- SCROLL-TIED OPACITY FADE based on about section proximity ---
      if (isTriggeredState && metaCanvas && aboutContent) {
        const aboutRect = aboutContent.getBoundingClientRect();
        const vh = window.innerHeight;

        // Safe zone: about content top is below 75% of viewport height
        // Danger zone: about content top is at or above 50% of viewport height
        const safeThreshold = vh * 0.75;
        const dangerThreshold = vh * 0.50;

        let opacity;
        if (aboutRect.top >= safeThreshold) {
          opacity = 1;
        } else if (aboutRect.top <= dangerThreshold) {
          opacity = 0;
        } else {
          opacity = (aboutRect.top - dangerThreshold) / (safeThreshold - dangerThreshold);
          opacity = Math.max(0, Math.min(1, opacity));
        }

        // Apply to both metamorphosis canvas AND period rectangle SVG
        metaCanvas.style.opacity = String(opacity);
        if (periodRectSvg) {
          periodRectSvg.style.opacity = String(opacity);
        }
      }
    }

    // Listen for scroll (RAF-throttled)
    let scrollTicking = false;
    window.addEventListener('scroll', () => {
      if (!scrollTicking) {
        requestAnimationFrame(() => {
          checkHeroScroll();
          scrollTicking = false;
        });
        scrollTicking = true;
      }
    }, { passive: true });

    // Initialize on DOM ready
    function init() {
      initRefs();
      checkHeroScroll();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>

  <!-- POINT Semantic Animation: Collapse to dot (SCROLL-TIED) -->
  <script type="module">
    import { animate, stagger, createTimeline, utils } from 'animejs';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let pointTl = null;
    let offsets = [];

    function initPointAnimation() {
      if (split) split.revert();
      if (pointTl) pointTl.pause();

      const container = document.querySelector('.point-animation');
      const wordEl = document.querySelector('.point-word');
      const dot = document.querySelector('.point-dot');

      if (!container || !wordEl || !dot) return;

      split = splitTextIntoChars(wordEl);

      // Calculate center and offsets (pre-compute for deterministic seeking)
      const wordRect = wordEl.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const centerX = (wordRect.left + wordRect.width / 2) - containerRect.left;
      const centerY = (wordRect.top + wordRect.height / 2) - containerRect.top;

      dot.style.left = `${centerX}px`;
      dot.style.top = `${centerY}px`;
      dot.style.transform = 'translate(-50%, -50%)';

      offsets = split.chars.map(char => {
        const rect = char.getBoundingClientRect();
        const charCenterX = rect.left + rect.width / 2 - containerRect.left;
        const charCenterY = rect.top + rect.height / 2 - containerRect.top;
        return { x: centerX - charCenterX, y: centerY - charCenterY };
      });

      utils.set(split.chars, { translateX: 0, translateY: 0, scale: 1, opacity: 1 });
      utils.set(dot, { opacity: 0, scale: 0 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      pointTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'outQuad' }
      });

      // === FORWARD: Characters collapse to dot ===
      pointTl.add(split.chars, {
        translateX: (el, i) => offsets[i].x,
        translateY: (el, i) => offsets[i].y,
        scale: [1, 0],
        opacity: [1, 0],
        duration: 500,
        delay: stagger(40, { from: 'edges' }),
        ease: 'inQuad'
      });

      pointTl.add(dot, {
        opacity: [0, 1],
        scale: [0, 1],
        duration: 300,
        ease: 'outBack'
      }, '-=200');

      // === PAUSE ===
      pointTl.add({}, { duration: 800 });

      // === REVERSE: Dot expands back to word ===
      pointTl.add(dot, {
        opacity: [1, 0],
        scale: [1, 0],
        duration: 200,
        ease: 'inBack'
      });

      pointTl.add(split.chars, {
        translateX: 0,
        translateY: 0,
        scale: [0, 1],
        opacity: [0, 1],
        duration: 400,
        delay: stagger(30, { from: 'center' }),
        ease: 'outBack'
      }, '-=100');

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('point-animation'),
        update: (progress) => {
          if (pointTl) {
            pointTl.seek(pointTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPointAnimation);
    } else {
      initPointAnimation();
    }

    // Replay function for debugging
    window.replayPoint = () => {
      if (pointTl) {
        pointTl.seek(0);
        pointTl.play();
      }
    };
  </script>

  <!-- BESPOKE Semantic Animation: Scatter and assemble (SCROLL-TIED) -->
  <script type="module">
    import { animate, stagger, createTimeline, utils } from 'animejs';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let bespokeTl = null;
    let scatterData = [];

    function initBespokeAnimation() {
      if (split) split.revert();
      if (bespokeTl) bespokeTl.pause();

      const wordEl = document.querySelector('.bespoke-word');
      if (!wordEl) return;

      split = splitTextIntoChars(wordEl);

      // Pre-compute scatter positions for deterministic seeking
      scatterData = split.chars.map(() => ({
        x: (Math.random() - 0.5) * 150,
        y: (Math.random() - 0.5) * 100,
        rotation: (Math.random() - 0.5) * 45
      }));

      // Start visible and normal
      utils.set(split.chars, { translateX: 0, translateY: 0, rotate: 0, scale: 1, opacity: 1 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      bespokeTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'outQuad' }
      });

      // === FORWARD: Scatter out ===
      bespokeTl.add(split.chars, {
        translateX: (el, i) => scatterData[i].x,
        translateY: (el, i) => scatterData[i].y,
        rotate: (el, i) => scatterData[i].rotation,
        scale: 0.6,
        opacity: 0.4,
        duration: 500,
        delay: stagger(40, { from: 'center' })
      });

      // === PAUSE ===
      bespokeTl.add({}, { duration: 600 });

      // === REVERSE: Assemble back ===
      bespokeTl.add(split.chars, {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        scale: 1,
        opacity: 1,
        duration: 500,
        delay: stagger(40, { from: 'random' }),
        ease: 'outBack'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('bespoke-animation'),
        update: (progress) => {
          if (bespokeTl) {
            bespokeTl.seek(bespokeTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initBespokeAnimation);
    } else {
      initBespokeAnimation();
    }

    // Replay function for debugging
    window.replayBespoke = () => {
      if (bespokeTl) {
        bespokeTl.seek(0);
        bespokeTl.play();
      }
    };
  </script>

  <!-- FRICTION Semantic Animation: Vibrate and settle (SCROLL-TIED) -->
  <script type="module">
    import { animate, stagger, createTimeline, utils } from 'animejs';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let frictionTl = null;

    function initFrictionAnimation() {
      if (split) split.revert();
      if (frictionTl) frictionTl.pause();

      const wordEl = document.querySelector('.friction-word');
      if (!wordEl) return;

      split = splitTextIntoChars(wordEl);

      utils.set(split.chars, { translateX: 0, translateY: 0, rotate: 0 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      frictionTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'linear' }
      });

      // === FORWARD: Intense vibration ===
      frictionTl.add(split.chars, {
        translateX: [-3, 3, -2, 2, -3, 3, -2, 2],
        translateY: [-1, 1, -1.5, 1.5, -1, 1],
        rotate: [-2, 2, -1.5, 1.5, -2, 2],
        duration: 400,
        delay: stagger(20)
      });

      // Medium vibration
      frictionTl.add(split.chars, {
        translateX: [-2, 2, -1.5, 1.5, -1, 1],
        translateY: [-0.5, 0.5, -1, 1],
        rotate: [-1, 1, -0.5, 0.5],
        duration: 300
      });

      // Light vibration
      frictionTl.add(split.chars, {
        translateX: [-1, 1, -0.5, 0.5, -0.3, 0.3],
        translateY: [-0.3, 0.3, -0.2, 0.2],
        rotate: [-0.3, 0.3],
        duration: 250
      });

      // Settle
      frictionTl.add(split.chars, {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        duration: 200,
        ease: 'outQuad'
      });

      // === PAUSE ===
      frictionTl.add({}, { duration: 600 });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('friction-animation'),
        update: (progress) => {
          if (frictionTl) {
            frictionTl.seek(frictionTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFrictionAnimation);
    } else {
      initFrictionAnimation();
    }

    // Replay function for debugging
    window.replayFriction = () => {
      if (frictionTl) {
        frictionTl.seek(0);
        frictionTl.play();
      }
    };
  </script>

  <!-- JARGON Semantic Animation: Scramble decode (IntersectionObserver - NOT scroll-tied) -->
  <script type="module">
    import { animate, createTimeline, utils } from 'animejs';

    const SCRAMBLE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*!?';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        span.dataset.original = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let intervals = [];
    let timeouts = [];

    function initJargonAnimation() {
      // Cleanup
      intervals.forEach(id => clearInterval(id));
      timeouts.forEach(id => clearTimeout(id));
      intervals = [];
      timeouts = [];
      if (split) split.revert();

      const wordEl = document.querySelector('.jargon-word');
      if (!wordEl) return;

      split = splitTextIntoChars(wordEl);

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // === FORWARD: Scramble then decode left-to-right ===
      split.chars.forEach((char, i) => {
        char.classList.add('scrambling');

        // Start scrambling
        const intervalId = setInterval(() => {
          char.textContent = SCRAMBLE_CHARS[Math.floor(Math.random() * SCRAMBLE_CHARS.length)];
        }, 50);
        intervals.push(intervalId);

        // Decode after staggered delay
        const timeoutId = setTimeout(() => {
          clearInterval(intervalId);
          char.textContent = char.dataset.original;
          char.classList.remove('scrambling');
          char.classList.add('decoded');
          utils.set(char, { scale: [1.2, 1] });
        }, 300 + (i * 150));
        timeouts.push(timeoutId);
      });

      // === PAUSE then REVERSE: Re-scramble right-to-left then decode ===
      const pauseTimeout = setTimeout(() => {
        // Re-scramble
        split.chars.forEach((char, i) => {
          const delay = (split.chars.length - 1 - i) * 100;

          const scrambleTimeout = setTimeout(() => {
            char.classList.remove('decoded');
            char.classList.add('scrambling');

            const intervalId = setInterval(() => {
              char.textContent = SCRAMBLE_CHARS[Math.floor(Math.random() * SCRAMBLE_CHARS.length)];
            }, 50);
            intervals.push(intervalId);

            // Decode back
            const decodeTimeout = setTimeout(() => {
              clearInterval(intervalId);
              char.textContent = char.dataset.original;
              char.classList.remove('scrambling');
              char.classList.add('decoded');
            }, 400);
            timeouts.push(decodeTimeout);
          }, delay);
          timeouts.push(scrambleTimeout);
        });
      }, 1500);
      timeouts.push(pauseTimeout);
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          initJargonAnimation();
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.5 });

    const jargonEl = document.getElementById('jargon-animation');
    if (jargonEl) observer.observe(jargonEl);
    window.replayJargon = initJargonAnimation;
  </script>

  <!-- FOCUS Semantic Animation: Context blur (SCROLL-TIED) -->
  <script type="module">
    import { createTimeline, utils } from 'animejs';

    let focusTl = null;

    function initFocusAnimation() {
      if (focusTl) focusTl.pause();

      const word = document.querySelector('.focus-word');
      const contextWords = document.querySelectorAll('.focus-context');

      if (!word || !contextWords.length) return;

      utils.set(word, { scale: 1 });
      utils.set(contextWords, { filter: 'blur(0px)', opacity: 1 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      focusTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'inOutQuad' }
      });

      // === FORWARD: Blur context, emphasize focus ===
      focusTl.add(contextWords, {
        filter: ['blur(0px)', 'blur(3px)'],
        opacity: [1, 0.4],
        duration: 400
      });

      focusTl.add(word, {
        scale: [1, 1.15],
        duration: 300,
        ease: 'outBack'
      }, '-=300');

      // === PAUSE ===
      focusTl.add({}, { duration: 800 });

      // === REVERSE: Clear context ===
      focusTl.add(word, {
        scale: [1.15, 1],
        duration: 300,
        ease: 'inOutQuad'
      });

      focusTl.add(contextWords, {
        filter: ['blur(3px)', 'blur(0px)'],
        opacity: [0.4, 1],
        duration: 400
      }, '-=200');

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('focus-animation'),
        update: (progress) => {
          if (focusTl) {
            focusTl.seek(focusTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFocusAnimation);
    } else {
      initFocusAnimation();
    }

    // Replay function for debugging
    window.replayFocus = () => {
      if (focusTl) {
        focusTl.seek(0);
        focusTl.play();
      }
    };
  </script>

  <!-- MATTERS Semantic Animation: Scale emphasis (SCROLL-TIED) -->
  <script type="module">
    import { createTimeline, utils } from 'animejs';

    let mattersTl = null;

    function initMattersAnimation() {
      if (mattersTl) mattersTl.pause();

      const word = document.querySelector('.matters-word');
      if (!word) return;

      utils.set(word, { scale: 1 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      mattersTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'inOutQuad' }
      });

      // === FORWARD: Grow to emphasize ===
      mattersTl.add(word, {
        scale: [1, 1.3],
        duration: 400,
        ease: 'outBack'
      });

      // === PAUSE ===
      mattersTl.add({}, { duration: 600 });

      // === REVERSE: Return to normal ===
      mattersTl.add(word, {
        scale: [1.3, 1],
        duration: 350,
        ease: 'inOutQuad'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('matters-animation'),
        update: (progress) => {
          if (mattersTl) {
            mattersTl.seek(mattersTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMattersAnimation);
    } else {
      initMattersAnimation();
    }

    // Replay function for debugging
    window.replayMatters = () => {
      if (mattersTl) {
        mattersTl.seek(0);
        mattersTl.play();
      }
    };
  </script>

  <!-- ELIMINATE Semantic Animation: Strikethrough then trapdoor fall (SCROLL-TIED) -->
  <script type="module">
    import { createTimeline, utils } from 'animejs';

    let eliminateTl = null;

    function initEliminateAnimation() {
      if (eliminateTl) eliminateTl.pause();

      const word = document.querySelector('.eliminate-word');
      const line = document.querySelector('.strike-line');

      if (!word || !line) return;

      // Reset
      utils.set(word, { translateY: 0, opacity: 1 });
      utils.set(line, { strokeDashoffset: 200 });
      line.setAttribute('y1', 10);
      line.setAttribute('y2', 10);

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      eliminateTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'outQuad' }
      });

      // === FORWARD ===

      // Phase 1: Draw strikethrough
      eliminateTl.add(line, {
        strokeDashoffset: [200, 0],
        duration: 300,
        ease: 'inOutQuad'
      });

      // Phase 2: Line falls to underline
      eliminateTl.add(line, {
        y1: 18,
        y2: 18,
        duration: 200,
        ease: 'inQuad'
      }, '+=100');

      // Phase 3: Word falls through (trapdoor)
      eliminateTl.add(word, {
        translateY: [0, 30],
        opacity: [1, 0],
        duration: 300,
        ease: 'inQuad'
      }, '+=100');

      // === PAUSE ===
      eliminateTl.add({}, { duration: 600 });

      // === REVERSE ===

      // Word rises back
      eliminateTl.add(word, {
        translateY: [30, 0],
        opacity: [0, 1],
        duration: 300,
        ease: 'outQuad'
      });

      // Line rises back to middle
      eliminateTl.add(line, {
        y1: 10,
        y2: 10,
        duration: 200,
        ease: 'outQuad'
      });

      // Line retracts
      eliminateTl.add(line, {
        strokeDashoffset: [0, 200],
        duration: 300,
        ease: 'inOutQuad'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('eliminate-animation'),
        update: (progress) => {
          if (eliminateTl) {
            eliminateTl.seek(eliminateTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initEliminateAnimation);
    } else {
      initEliminateAnimation();
    }

    // Replay function for debugging
    window.replayEliminate = () => {
      if (eliminateTl) {
        eliminateTl.seek(0);
        eliminateTl.play();
      }
    };
  </script>

  <!-- CLARITY Semantic Animation: Blur to crystal clear (SCROLL-TIED) -->
  <script type="module">
    import { createTimeline, utils } from 'animejs';

    let clarityTl = null;

    function initClarityAnimation() {
      if (clarityTl) clarityTl.pause();

      const word = document.querySelector('.clarity-word');
      if (!word) return;

      utils.set(word, { filter: 'blur(0px)', opacity: 1 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      clarityTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'inOutQuad' }
      });

      // === FORWARD: Clear -> Blur -> Crystal Clear ===

      // Phase 1: Blur out (losing clarity)
      clarityTl.add(word, {
        filter: ['blur(0px)', 'blur(6px)'],
        opacity: [1, 0.5],
        duration: 400
      });

      // Phase 2: Hold blurry (PAUSE)
      clarityTl.add({}, { duration: 300 });

      // Phase 3: Snap to crystal clear (gaining clarity)
      clarityTl.add(word, {
        filter: ['blur(6px)', 'blur(0px)'],
        opacity: [0.5, 1],
        duration: 300,
        ease: 'outQuad'
      });

      // Phase 4: Brightness pulse (moment of clarity)
      clarityTl.add(word, {
        filter: ['blur(0px) brightness(1)', 'blur(0px) brightness(1.3)', 'blur(0px) brightness(1)'],
        duration: 400,
        ease: 'inOutSine'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('clarity-animation'),
        update: (progress) => {
          if (clarityTl) {
            clarityTl.seek(clarityTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initClarityAnimation);
    } else {
      initClarityAnimation();
    }

    // Replay function for debugging
    window.replayClarity = () => {
      if (clarityTl) {
        clarityTl.seek(0);
        clarityTl.play();
      }
    };
  </script>

  <!-- PATH Semantic Animation: Letters wave along a path (SCROLL-TIED) -->
  <script type="module">
    import { animate, stagger, createTimeline, utils } from 'animejs';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let pathTl = null;

    function initPathAnimation() {
      if (split) split.revert();
      if (pathTl) pathTl.pause();

      const wordEl = document.querySelector('.path-word');
      if (!wordEl) return;

      split = splitTextIntoChars(wordEl);

      utils.set(split.chars, { translateX: 0, translateY: 0 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      pathTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'inOutSine' }
      });

      // === FORWARD: Wave motion (like following a curved path) ===

      // Phase 1: Letters wave up and down in sequence
      pathTl.add(split.chars, {
        translateY: [0, -8, 0, 8, 0],
        duration: 800,
        delay: stagger(100, { from: 'first' })
      });

      // Phase 2: Horizontal wave (serpentine)
      pathTl.add(split.chars, {
        translateX: [0, 4, 0, -4, 0],
        translateY: [0, -4, 0, 4, 0],
        duration: 600,
        delay: stagger(80, { from: 'first' })
      });

      // Phase 3: Settle back
      pathTl.add(split.chars, {
        translateX: 0,
        translateY: 0,
        duration: 300,
        ease: 'outQuad'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('path-animation'),
        update: (progress) => {
          if (pathTl) {
            pathTl.seek(pathTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPathAnimation);
    } else {
      initPathAnimation();
    }

    // Replay function for debugging
    window.replayPath = () => {
      if (pathTl) {
        pathTl.seek(0);
        pathTl.play();
      }
    };
  </script>

  <!-- RESISTANCE Semantic Animation: Compress then elastic release (SCROLL-TIED) -->
  <script type="module">
    import { animate, stagger, createTimeline, utils } from 'animejs';

    function splitTextIntoChars(el) {
      const text = el.textContent;
      el.innerHTML = '';
      const chars = [];
      for (const char of text) {
        const span = document.createElement('span');
        span.className = 'char';
        span.textContent = char;
        el.appendChild(span);
        chars.push(span);
      }
      return { chars, text, revert: () => { el.textContent = text; } };
    }

    let split = null;
    let resistanceTl = null;

    function initResistanceAnimation() {
      if (split) split.revert();
      if (resistanceTl) resistanceTl.pause();

      const wordEl = document.querySelector('.resistance-word');
      if (!wordEl) return;

      split = splitTextIntoChars(wordEl);

      utils.set(split.chars, { translateX: 0, scaleX: 1, skewX: 0 });

      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      // Create timeline with autoplay: false for scroll control
      resistanceTl = createTimeline({
        autoplay: false,
        defaults: { ease: 'linear' }
      });

      // === FORWARD: Build pressure -> compress -> release ===

      // Phase 1: Building pressure (lean and compress)
      resistanceTl.add(split.chars, {
        translateX: [0, -5],
        scaleX: [1, 0.92],
        skewX: [0, 4],
        duration: 400,
        ease: 'inQuad',
        delay: stagger(25, { from: 'first' })
      });

      // Phase 2: Maximum compression
      resistanceTl.add(split.chars, {
        translateX: (el, i) => -8 - (i * 1.5),
        scaleX: 0.85,
        skewX: 6,
        duration: 300,
        ease: 'inQuad'
      });

      // Phase 3: Breakthrough! Elastic release
      resistanceTl.add(split.chars, {
        translateX: [null, 10, 0],
        scaleX: [0.85, 1.1, 1],
        skewX: [6, -3, 0],
        duration: 600,
        ease: 'outElastic(1, 0.6)',
        delay: stagger(20, { from: 'last' })
      });

      // Phase 4: Victory settle
      resistanceTl.add(split.chars, {
        scale: [1, 1.05, 1],
        duration: 250,
        ease: 'inOutSine'
      });

      // Register with scroll controller
      window.registerScrollAnimation({
        element: document.getElementById('resistance-animation'),
        update: (progress) => {
          if (resistanceTl) {
            resistanceTl.seek(resistanceTl.duration * progress);
          }
        }
      });
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initResistanceAnimation);
    } else {
      initResistanceAnimation();
    }

    // Replay function for debugging
    window.replayResistance = () => {
      if (resistanceTl) {
        resistanceTl.seek(0);
        resistanceTl.play();
      }
    };
  </script>

  <!-- Custom Cursor (Optional Enhancement)
       Small morphing dot that indicates interactive elements.
       Test with users - if it feels gimmicky, keep native cursors. -->
  <script type="module">
    import { initCustomCursor } from './js/cursor.js';
    initCustomCursor();
  </script>

  <!-- Logo sprite animation (proximity-triggered retro CRT frames) -->
  <script type="module">
    import { initLogoSprite } from './js/logo-sprite.js';
    initLogoSprite();
  </script>

  <!-- Contact section animations (title bounce, underline draw, border draw, text scramble) -->
  <script type="module">
    import { initContactAnimations } from './js/contact-animations.js';
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initContactAnimations);
    } else {
      initContactAnimations();
    }
  </script>

  <!-- Magnetic Cursor & Metamorphosis Animation -->
  <script type="module">
    import { initMagneticCursor } from './js/magnetic-cursor.js';
    import { initMetamorphosis } from './js/metamorphosis-canvas.js';

    // Initialize after DOM ready and cursor.js has created .custom-cursor
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure cursor.js has initialized first
        setTimeout(() => {
          // Autoplay metamorphosis on page load (not scroll-tied)
          initMetamorphosis({ autoplay: true, autoplayDelay: 800 });
          initMagneticCursor();
        }, 150);
      });
    } else {
      setTimeout(() => {
        // Autoplay metamorphosis on page load (not scroll-tied)
        initMetamorphosis({ autoplay: true, autoplayDelay: 800 });
        initMagneticCursor();
      }, 150);
    }
  </script>

  <!-- Cal.com Embed Script for Booking Modal -->
  <script>
    (function (C, A, L) {
      let p = function (a, ar) { a.q.push(ar); };
      let d = C.document;
      C.Cal = C.Cal || function () {
        let cal = C.Cal;
        let ar = arguments;
        if (!cal.loaded) {
          cal.ns = {};
          cal.q = cal.q || [];
          d.head.appendChild(d.createElement('script')).src = A;
          cal.loaded = true;
        }
        if (ar[0] === L) {
          const api = function () { p(api, arguments); };
          const namespace = ar[1];
          api.q = api.q || [];
          if (typeof namespace === 'string') {
            cal.ns[namespace] = cal.ns[namespace] || api;
            p(cal.ns[namespace], ar);
            p(cal, ['initNamespace', namespace]);
          } else p(cal, ar);
          return;
        }
        p(cal, ar);
      };
    })(window, 'https://app.cal.com/embed/embed.js', 'init');

    Cal('init', 'booking', { origin: 'https://cal.com' });
    Cal.ns.booking('ui', {
      styles: { branding: { brandColor: '#000000' } },
      hideEventTypeDetails: false,
      layout: 'month_view'
    });
  </script>

  <!-- Hero Text Emergence Animation (DISABLED - using video-reveal instead)
  <script type="module">
    import { initHeroEmergence } from './js/hero-emergence/index.js';

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => initHeroEmergence());
    } else {
      initHeroEmergence();
    }
  </script>
  -->
</body>
</html>
